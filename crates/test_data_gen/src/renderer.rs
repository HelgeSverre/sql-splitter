//! SQL renderers for different dialects.
//!
//! Renders generated data to MySQL, PostgreSQL, or SQLite SQL.

use crate::generator::{GeneratedData, SqlValue, TableData};
use std::io::{self, Write};

/// Target SQL dialect
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub enum Dialect {
    #[default]
    MySql,
    Postgres,
    Sqlite,
    Mssql,
}

impl std::str::FromStr for Dialect {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "mysql" | "mariadb" => Ok(Dialect::MySql),
            "postgres" | "postgresql" | "pg" => Ok(Dialect::Postgres),
            "sqlite" | "sqlite3" => Ok(Dialect::Sqlite),
            "mssql" | "sqlserver" | "tsql" => Ok(Dialect::Mssql),
            _ => Err(format!(
                "Unknown dialect: {}. Use mysql, postgres, sqlite, or mssql",
                s
            )),
        }
    }
}

impl std::fmt::Display for Dialect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Dialect::MySql => write!(f, "mysql"),
            Dialect::Postgres => write!(f, "postgres"),
            Dialect::Sqlite => write!(f, "sqlite"),
            Dialect::Mssql => write!(f, "mssql"),
        }
    }
}

/// Renderer configuration
#[derive(Debug, Clone)]
pub struct RenderConfig {
    pub dialect: Dialect,
    /// Include CREATE TABLE statements
    pub include_schema: bool,
    /// Use multi-row INSERT syntax
    pub batch_inserts: bool,
    /// Max rows per INSERT statement (for batch mode)
    pub batch_size: usize,
    /// Use PostgreSQL COPY instead of INSERT
    pub use_copy: bool,
    /// Add comments between tables
    pub add_comments: bool,
    /// Use GO batch separators for MSSQL
    pub use_go_separator: bool,
    /// Use [dbo]. schema prefix for MSSQL
    pub use_schema_prefix: bool,
    /// Use named CONSTRAINT syntax (e.g., CONSTRAINT [PK_table])
    pub use_named_constraints: bool,
}

impl Default for RenderConfig {
    fn default() -> Self {
        Self {
            dialect: Dialect::MySql,
            include_schema: true,
            batch_inserts: true,
            batch_size: 100,
            use_copy: false, // Only for Postgres
            add_comments: true,
            use_go_separator: false,
            use_schema_prefix: false,
            use_named_constraints: false,
        }
    }
}

impl RenderConfig {
    pub fn mysql() -> Self {
        Self {
            dialect: Dialect::MySql,
            ..Default::default()
        }
    }

    pub fn postgres() -> Self {
        Self {
            dialect: Dialect::Postgres,
            use_copy: true,
            ..Default::default()
        }
    }

    pub fn postgres_inserts() -> Self {
        Self {
            dialect: Dialect::Postgres,
            use_copy: false,
            ..Default::default()
        }
    }

    pub fn sqlite() -> Self {
        Self {
            dialect: Dialect::Sqlite,
            ..Default::default()
        }
    }

    pub fn mssql() -> Self {
        Self {
            dialect: Dialect::Mssql,
            ..Default::default()
        }
    }

    /// MSSQL with production-style output (GO separators, [dbo]. prefix, named constraints)
    pub fn mssql_production() -> Self {
        Self {
            dialect: Dialect::Mssql,
            use_go_separator: true,
            use_schema_prefix: true,
            use_named_constraints: true,
            ..Default::default()
        }
    }
}

/// Render generated data to SQL
pub struct Renderer {
    config: RenderConfig,
}

impl Renderer {
    pub fn new(config: RenderConfig) -> Self {
        Self { config }
    }

    /// Render all data to a writer
    pub fn render<W: Write>(&self, data: &GeneratedData, mut w: W) -> io::Result<()> {
        self.render_header(&mut w)?;

        if self.config.include_schema {
            self.render_schema(data, &mut w)?;
        }

        self.render_data(data, &mut w)?;

        self.render_footer(&mut w)?;

        Ok(())
    }

    /// Render to a String
    pub fn render_to_string(&self, data: &GeneratedData) -> io::Result<String> {
        let mut buf = Vec::new();
        self.render(data, &mut buf)?;
        String::from_utf8(buf).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))
    }

    fn render_header<W: Write>(&self, w: &mut W) -> io::Result<()> {
        match self.config.dialect {
            Dialect::MySql => {
                writeln!(w, "-- Generated by test_data_gen")?;
                writeln!(w, "-- Dialect: MySQL")?;
                writeln!(w)?;
                writeln!(w, "SET NAMES utf8mb4;")?;
                writeln!(w, "SET FOREIGN_KEY_CHECKS = 0;")?;
                writeln!(w)?;
            }
            Dialect::Postgres => {
                writeln!(w, "-- Generated by test_data_gen")?;
                writeln!(w, "-- Dialect: PostgreSQL")?;
                writeln!(w)?;
                writeln!(w, "SET client_encoding = 'UTF8';")?;
                writeln!(w)?;
            }
            Dialect::Sqlite => {
                writeln!(w, "-- Generated by test_data_gen")?;
                writeln!(w, "-- Dialect: SQLite")?;
                writeln!(w)?;
                writeln!(w, "PRAGMA foreign_keys = OFF;")?;
                writeln!(w)?;
            }
            Dialect::Mssql => {
                writeln!(w, "-- Generated by test_data_gen")?;
                writeln!(w, "-- Dialect: MSSQL")?;
                writeln!(w)?;
                if self.config.use_go_separator {
                    writeln!(w, "SET ANSI_NULLS ON")?;
                    writeln!(w, "GO")?;
                    writeln!(w, "SET QUOTED_IDENTIFIER ON")?;
                    writeln!(w, "GO")?;
                    writeln!(w, "SET NOCOUNT ON")?;
                    writeln!(w, "GO")?;
                } else {
                    writeln!(w, "SET ANSI_NULLS ON;")?;
                    writeln!(w, "SET QUOTED_IDENTIFIER ON;")?;
                    writeln!(w, "SET NOCOUNT ON;")?;
                }
                writeln!(w)?;
            }
        }
        Ok(())
    }

    fn render_footer<W: Write>(&self, w: &mut W) -> io::Result<()> {
        writeln!(w)?;
        match self.config.dialect {
            Dialect::MySql => {
                writeln!(w, "SET FOREIGN_KEY_CHECKS = 1;")?;
            }
            Dialect::Postgres => {
                // No footer needed
            }
            Dialect::Sqlite => {
                writeln!(w, "PRAGMA foreign_keys = ON;")?;
            }
            Dialect::Mssql => {
                // No footer needed for MSSQL
            }
        }
        Ok(())
    }

    fn render_schema<W: Write>(&self, data: &GeneratedData, w: &mut W) -> io::Result<()> {
        if self.config.add_comments {
            writeln!(w, "-- ==============================================")?;
            writeln!(w, "-- Schema")?;
            writeln!(w, "-- ==============================================")?;
            writeln!(w)?;
        }

        for table in &data.tables {
            self.render_create_table(table, w)?;
            writeln!(w)?;
        }

        Ok(())
    }

    fn render_create_table<W: Write>(&self, table: &TableData, w: &mut W) -> io::Result<()> {
        let (q_open, q_close) = self.quote_chars();
        let table_ref = self.format_table_name(&table.table_name);

        writeln!(w, "CREATE TABLE {} (", table_ref)?;

        // Get column definitions based on table schema
        let col_defs = self.infer_column_definitions(table);

        // Check if we need named constraints (for MSSQL production style)
        let has_pk_column = table.columns.first().map(|c| c == "id").unwrap_or(false);
        let use_constraint = self.config.use_named_constraints 
            && self.config.dialect == Dialect::Mssql 
            && has_pk_column;

        for (i, (col_name, col_def)) in table.columns.iter().zip(col_defs.iter()).enumerate() {
            let is_last = i == table.columns.len() - 1;
            
            // For MSSQL with named constraints, we need to strip inline PRIMARY KEY and add it as constraint
            let col_def_adjusted = if use_constraint && col_name == "id" {
                col_def.replace(" PRIMARY KEY", "")
            } else {
                col_def.clone()
            };
            
            let comma = if !is_last || use_constraint { "," } else { "" };
            writeln!(
                w,
                "    {}{}{} {}{}",
                q_open, col_name, q_close, col_def_adjusted, comma
            )?;
        }

        // Add named PK constraint for MSSQL
        if use_constraint {
            writeln!(
                w,
                "    CONSTRAINT {}PK_{}{} PRIMARY KEY CLUSTERED ({}id{})",
                q_open, table.table_name, q_close, q_open, q_close
            )?;
        }

        write!(w, ")")?;
        
        // MSSQL: add ON [PRIMARY] filegroup
        if self.config.dialect == Dialect::Mssql && self.config.use_schema_prefix {
            write!(w, " ON [PRIMARY]")?;
        }
        
        writeln!(w, ";")?;
        
        // Add GO separator for MSSQL
        if self.config.use_go_separator {
            writeln!(w, "GO")?;
        }

        Ok(())
    }

    /// Format a table name with optional schema prefix
    fn format_table_name(&self, table_name: &str) -> String {
        let (q_open, q_close) = self.quote_chars();
        if self.config.use_schema_prefix && self.config.dialect == Dialect::Mssql {
            format!("[dbo].{}{}{}", q_open, table_name, q_close)
        } else {
            format!("{}{}{}", q_open, table_name, q_close)
        }
    }

    fn infer_column_definitions(&self, table: &TableData) -> Vec<String> {
        // Infer column types from table name and column names
        table
            .columns
            .iter()
            .enumerate()
            .map(|(idx, col)| self.infer_column_type(&table.table_name, col, idx))
            .collect()
    }

    fn infer_column_type(&self, _table_name: &str, col_name: &str, idx: usize) -> String {
        let is_pk = col_name == "id" && idx == 0;
        let is_fk = col_name.ends_with("_id") && !is_pk;
        let is_timestamp = col_name.ends_with("_at");

        match self.config.dialect {
            Dialect::MySql => {
                if is_pk {
                    "INT AUTO_INCREMENT PRIMARY KEY".to_string()
                } else if is_fk {
                    "INT".to_string()
                } else if is_timestamp {
                    "DATETIME".to_string()
                } else if col_name == "active" || col_name == "completed" || col_name == "is_system"
                {
                    "TINYINT(1)".to_string()
                } else if col_name == "price" || col_name == "total" || col_name == "unit_price" {
                    "DECIMAL(10,2)".to_string()
                } else if col_name == "quantity" || col_name == "priority" || col_name == "level" {
                    "INT".to_string()
                } else if col_name == "body" {
                    "TEXT".to_string()
                } else {
                    "VARCHAR(255)".to_string()
                }
            }
            Dialect::Postgres => {
                if is_pk {
                    "SERIAL PRIMARY KEY".to_string()
                } else if is_fk {
                    "INTEGER".to_string()
                } else if is_timestamp {
                    "TIMESTAMP".to_string()
                } else if col_name == "active" || col_name == "completed" || col_name == "is_system"
                {
                    "BOOLEAN".to_string()
                } else if col_name == "price" || col_name == "total" || col_name == "unit_price" {
                    "DECIMAL(10,2)".to_string()
                } else if col_name == "quantity" || col_name == "priority" || col_name == "level" {
                    "INTEGER".to_string()
                } else if col_name == "body" {
                    "TEXT".to_string()
                } else {
                    "VARCHAR(255)".to_string()
                }
            }
            Dialect::Sqlite => {
                if is_pk {
                    "INTEGER PRIMARY KEY AUTOINCREMENT".to_string()
                } else if is_fk {
                    "INTEGER".to_string()
                } else if is_timestamp {
                    "TEXT".to_string()
                } else if col_name == "active" || col_name == "completed" || col_name == "is_system"
                {
                    "INTEGER".to_string()
                } else if col_name == "price" || col_name == "total" || col_name == "unit_price" {
                    "REAL".to_string()
                } else if col_name == "quantity" || col_name == "priority" || col_name == "level" {
                    "INTEGER".to_string()
                } else {
                    "TEXT".to_string()
                }
            }
            Dialect::Mssql => {
                if is_pk {
                    "INT IDENTITY(1,1) NOT NULL PRIMARY KEY".to_string()
                } else if is_fk {
                    "INT".to_string()
                } else if is_timestamp {
                    "DATETIME2".to_string()
                } else if col_name == "active" || col_name == "completed" || col_name == "is_system"
                {
                    "BIT".to_string()
                } else if col_name == "price" || col_name == "total" || col_name == "unit_price" {
                    "DECIMAL(10,2)".to_string()
                } else if col_name == "quantity" || col_name == "priority" || col_name == "level" {
                    "INT".to_string()
                } else if col_name == "body" {
                    "NVARCHAR(MAX)".to_string()
                } else {
                    "NVARCHAR(255)".to_string()
                }
            }
        }
    }

    fn render_data<W: Write>(&self, data: &GeneratedData, w: &mut W) -> io::Result<()> {
        if self.config.add_comments {
            writeln!(w, "-- ==============================================")?;
            writeln!(w, "-- Data")?;
            writeln!(w, "-- ==============================================")?;
            writeln!(w)?;
        }

        for table in &data.tables {
            if table.rows.is_empty() {
                continue;
            }

            if self.config.add_comments {
                writeln!(
                    w,
                    "-- Table: {} ({} rows)",
                    table.table_name,
                    table.rows.len()
                )?;
            }

            if self.config.dialect == Dialect::Postgres && self.config.use_copy {
                self.render_copy(table, w)?;
            } else if self.config.batch_inserts {
                self.render_batch_inserts(table, w)?;
            } else {
                self.render_single_inserts(table, w)?;
            }

            writeln!(w)?;
        }

        Ok(())
    }

    fn render_batch_inserts<W: Write>(&self, table: &TableData, w: &mut W) -> io::Result<()> {
        let (q_open, q_close) = self.quote_chars();
        let table_ref = self.format_table_name(&table.table_name);

        for chunk in table.rows.chunks(self.config.batch_size) {
            writeln!(
                w,
                "INSERT INTO {} ({}) VALUES",
                table_ref,
                table
                    .columns
                    .iter()
                    .map(|c| format!("{}{}{}", q_open, c, q_close))
                    .collect::<Vec<_>>()
                    .join(", ")
            )?;

            for (i, row) in chunk.iter().enumerate() {
                let values = self.format_row(row);
                let comma = if i < chunk.len() - 1 { "," } else { ";" };
                writeln!(w, "({}){}", values, comma)?;
            }
            
            // Add GO separator for MSSQL
            if self.config.use_go_separator {
                writeln!(w, "GO")?;
            }
        }

        Ok(())
    }

    fn render_single_inserts<W: Write>(&self, table: &TableData, w: &mut W) -> io::Result<()> {
        let (q_open, q_close) = self.quote_chars();
        let table_ref = self.format_table_name(&table.table_name);

        for row in &table.rows {
            let values = self.format_row(row);
            writeln!(
                w,
                "INSERT INTO {} ({}) VALUES ({});",
                table_ref,
                table
                    .columns
                    .iter()
                    .map(|c| format!("{}{}{}", q_open, c, q_close))
                    .collect::<Vec<_>>()
                    .join(", "),
                values
            )?;
            
            // Add GO separator for MSSQL
            if self.config.use_go_separator {
                writeln!(w, "GO")?;
            }
        }

        Ok(())
    }

    fn render_copy<W: Write>(&self, table: &TableData, w: &mut W) -> io::Result<()> {
        writeln!(
            w,
            "COPY {} ({}) FROM stdin;",
            table.table_name,
            table.columns.join(", ")
        )?;

        for row in &table.rows {
            let values: Vec<String> = row.iter().map(|v| v.to_postgres_copy()).collect();
            writeln!(w, "{}", values.join("\t"))?;
        }

        writeln!(w, "\\.")?;

        Ok(())
    }

    fn format_row(&self, row: &[SqlValue]) -> String {
        row.iter()
            .map(|v| match self.config.dialect {
                Dialect::MySql => v.to_mysql(),
                Dialect::Postgres => v.to_postgres(),
                Dialect::Sqlite => v.to_sqlite(),
                Dialect::Mssql => v.to_mssql(),
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn quote_chars(&self) -> (&'static str, &'static str) {
        match self.config.dialect {
            Dialect::MySql => ("`", "`"),
            Dialect::Postgres => ("\"", "\""),
            Dialect::Sqlite => ("\"", "\""),
            Dialect::Mssql => ("[", "]"),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::generator::{Generator, Scale};

    #[test]
    fn test_mysql_render() {
        let mut gen = Generator::new(42, Scale::Small);
        let data = gen.generate();

        let renderer = Renderer::new(RenderConfig::mysql());
        let sql = renderer.render_to_string(&data).unwrap();

        assert!(sql.contains("SET NAMES utf8mb4;"));
        assert!(sql.contains("SET FOREIGN_KEY_CHECKS = 0;"));
        assert!(sql.contains("CREATE TABLE `tenants`"));
        assert!(sql.contains("INSERT INTO `tenants`"));
        assert!(sql.contains("SET FOREIGN_KEY_CHECKS = 1;"));
    }

    #[test]
    fn test_postgres_copy_render() {
        let mut gen = Generator::new(42, Scale::Small);
        let data = gen.generate();

        let renderer = Renderer::new(RenderConfig::postgres());
        let sql = renderer.render_to_string(&data).unwrap();

        assert!(sql.contains("SET client_encoding = 'UTF8';"));
        assert!(sql.contains("CREATE TABLE \"tenants\""));
        assert!(sql.contains("COPY tenants"));
        assert!(sql.contains("\\."));
    }

    #[test]
    fn test_postgres_insert_render() {
        let mut gen = Generator::new(42, Scale::Small);
        let data = gen.generate();

        let renderer = Renderer::new(RenderConfig::postgres_inserts());
        let sql = renderer.render_to_string(&data).unwrap();

        assert!(sql.contains("INSERT INTO \"tenants\""));
        assert!(!sql.contains("COPY "));
    }

    #[test]
    fn test_sqlite_render() {
        let mut gen = Generator::new(42, Scale::Small);
        let data = gen.generate();

        let renderer = Renderer::new(RenderConfig::sqlite());
        let sql = renderer.render_to_string(&data).unwrap();

        assert!(sql.contains("PRAGMA foreign_keys = OFF;"));
        assert!(sql.contains("CREATE TABLE \"tenants\""));
        assert!(sql.contains("INTEGER PRIMARY KEY AUTOINCREMENT"));
        assert!(sql.contains("PRAGMA foreign_keys = ON;"));
    }

    #[test]
    fn test_mssql_render() {
        let mut gen = Generator::new(42, Scale::Small);
        let data = gen.generate();

        let renderer = Renderer::new(RenderConfig::mssql());
        let sql = renderer.render_to_string(&data).unwrap();

        assert!(sql.contains("SET ANSI_NULLS ON;"));
        assert!(sql.contains("SET QUOTED_IDENTIFIER ON;"));
        assert!(sql.contains("CREATE TABLE [tenants]"));
        assert!(sql.contains("INT IDENTITY(1,1) NOT NULL PRIMARY KEY"));
        assert!(sql.contains("INSERT INTO [tenants]"));
        assert!(sql.contains("N'")); // Unicode string literals
    }
}
