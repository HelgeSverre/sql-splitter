//! Streaming generators for SQL fixture generation.
//!
//! Generates SQL directly to a writer without building all data in memory.
//! Two modes:
//! - Simple: uniform tables with configurable row/table counts
//! - MultiTenant: realistic multi-tenant schema with FK relationships

use rand::Rng;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use std::collections::HashMap;
use std::io::{self, BufWriter, Write};

use crate::fake::FakeData;
use crate::generator::Scale;
use crate::renderer::Dialect;

const CHARS: &[u8] = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";

/// Configuration for streaming generation
#[derive(Debug, Clone)]
pub struct StreamingConfig {
    pub dialect: Dialect,
    pub rows_per_table: usize,
    pub num_tables: usize,
    pub seed: u64,
    pub batch_size: usize,
    pub include_schema: bool,
    pub include_fk: bool,
    /// Use GO batch separators for MSSQL
    pub use_go_separator: bool,
    /// Use [dbo]. schema prefix for MSSQL
    pub use_schema_prefix: bool,
    /// Use named CONSTRAINT syntax for MSSQL
    pub use_named_constraints: bool,
}

impl Default for StreamingConfig {
    fn default() -> Self {
        Self {
            dialect: Dialect::MySql,
            rows_per_table: 25000,
            num_tables: 10,
            seed: 42,
            batch_size: 100,
            include_schema: true,
            include_fk: true,
            use_go_separator: false,
            use_schema_prefix: false,
            use_named_constraints: false,
        }
    }
}

/// Streaming generator that writes directly to output
pub struct StreamingGenerator {
    config: StreamingConfig,
    rng: ChaCha8Rng,
}

impl StreamingGenerator {
    pub fn new(config: StreamingConfig) -> Self {
        let rng = ChaCha8Rng::seed_from_u64(config.seed);
        Self { config, rng }
    }

    /// Generate SQL and write directly to the writer (streaming)
    pub fn generate<W: Write>(&mut self, writer: W) -> io::Result<()> {
        let mut w = BufWriter::with_capacity(256 * 1024, writer);

        self.write_header(&mut w)?;

        if self.config.include_schema {
            self.write_schema(&mut w)?;
        }

        self.write_data(&mut w)?;

        self.write_footer(&mut w)?;

        w.flush()
    }

    fn write_header<W: Write>(&self, w: &mut W) -> io::Result<()> {
        match self.config.dialect {
            Dialect::MySql => {
                writeln!(w, "-- Generated by test_data_gen (streaming)")?;
                writeln!(w, "-- Dialect: MySQL")?;
                writeln!(w)?;
                writeln!(w, "SET NAMES utf8mb4;")?;
                writeln!(w, "SET FOREIGN_KEY_CHECKS = 0;")?;
                writeln!(w)?;
            }
            Dialect::Postgres => {
                writeln!(w, "-- Generated by test_data_gen (streaming)")?;
                writeln!(w, "-- Dialect: PostgreSQL")?;
                writeln!(w)?;
                writeln!(w, "SET client_encoding = 'UTF8';")?;
                writeln!(w)?;
            }
            Dialect::Sqlite => {
                writeln!(w, "-- Generated by test_data_gen (streaming)")?;
                writeln!(w, "-- Dialect: SQLite")?;
                writeln!(w)?;
                writeln!(w, "PRAGMA foreign_keys = OFF;")?;
                writeln!(w)?;
            }
            Dialect::Mssql => {
                writeln!(w, "-- Generated by test_data_gen (streaming)")?;
                writeln!(w, "-- Dialect: MSSQL")?;
                writeln!(w)?;
                writeln!(w, "SET ANSI_NULLS ON;")?;
                writeln!(w, "SET QUOTED_IDENTIFIER ON;")?;
                writeln!(w, "SET NOCOUNT ON;")?;
                writeln!(w)?;
            }
        }
        Ok(())
    }

    fn write_footer<W: Write>(&self, w: &mut W) -> io::Result<()> {
        writeln!(w)?;
        match self.config.dialect {
            Dialect::MySql => {
                writeln!(w, "SET FOREIGN_KEY_CHECKS = 1;")?;
            }
            Dialect::Postgres | Dialect::Sqlite => {
                writeln!(w, "PRAGMA foreign_keys = ON;")?;
            }
            Dialect::Mssql => {
                // No footer needed for MSSQL
            }
        }
        Ok(())
    }

    fn write_schema<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        let (q_open, q_close) = self.quote_chars();

        for t in 0..self.config.num_tables {
            let table_name = format!("table_{:03}", t);

            writeln!(
                w,
                "DROP TABLE IF EXISTS {}{}{};",
                q_open, table_name, q_close
            )?;
            writeln!(w, "CREATE TABLE {}{}{} (", q_open, table_name, q_close)?;

            match self.config.dialect {
                Dialect::MySql => {
                    writeln!(
                        w,
                        "  {}id{} INT AUTO_INCREMENT PRIMARY KEY,",
                        q_open, q_close
                    )?;
                }
                Dialect::Postgres => {
                    writeln!(w, "  {}id{} SERIAL PRIMARY KEY,", q_open, q_close)?;
                }
                Dialect::Sqlite => {
                    writeln!(
                        w,
                        "  {}id{} INTEGER PRIMARY KEY AUTOINCREMENT,",
                        q_open, q_close
                    )?;
                }
                Dialect::Mssql => {
                    writeln!(
                        w,
                        "  {}id{} INT IDENTITY(1,1) NOT NULL PRIMARY KEY,",
                        q_open, q_close
                    )?;
                }
            }

            let (name_type, value_type, desc_type, parent_type) = match self.config.dialect {
                Dialect::Mssql => ("NVARCHAR(100)", "INT", "NVARCHAR(MAX)", "INT"),
                _ => ("VARCHAR(100)", "INTEGER", "TEXT", "INTEGER"),
            };

            writeln!(w, "  {}name{} {},", q_open, q_close, name_type)?;
            writeln!(w, "  {}value{} {},", q_open, q_close, value_type)?;
            write!(w, "  {}description{} {}", q_open, q_close, desc_type)?;

            if t > 0 && self.config.include_fk {
                let parent_table = format!("table_{:03}", t - 1);
                writeln!(w, ",")?;
                write!(w, "  {}parent_id{} {}", q_open, q_close, parent_type)?;

                if self.config.dialect != Dialect::Sqlite {
                    writeln!(w, ",")?;
                    write!(
                        w,
                        "  FOREIGN KEY ({}parent_id{}) REFERENCES {}{}{}({}id{})",
                        q_open, q_close, q_open, parent_table, q_close, q_open, q_close
                    )?;
                }
            }

            writeln!(w)?;
            writeln!(w, ");")?;
            writeln!(w)?;
        }

        Ok(())
    }

    fn write_data<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        let (q_open, q_close) = self.quote_chars();

        for t in 0..self.config.num_tables {
            let table_name = format!("table_{:03}", t);
            let has_parent = t > 0 && self.config.include_fk;

            // Write data in batches
            for batch_start in (0..self.config.rows_per_table).step_by(self.config.batch_size) {
                let batch_end =
                    (batch_start + self.config.batch_size).min(self.config.rows_per_table);

                match self.config.dialect {
                    Dialect::Postgres => {
                        self.write_copy_batch(
                            w,
                            &table_name,
                            t,
                            batch_start,
                            batch_end,
                            has_parent,
                        )?;
                    }
                    _ => {
                        self.write_insert_batch(
                            w,
                            &table_name,
                            t,
                            batch_start,
                            batch_end,
                            has_parent,
                            q_open,
                            q_close,
                        )?;
                    }
                }
            }

            writeln!(w)?;
        }

        Ok(())
    }

    #[allow(clippy::too_many_arguments)]
    fn write_insert_batch<W: Write>(
        &mut self,
        w: &mut W,
        table_name: &str,
        table_idx: usize,
        batch_start: usize,
        batch_end: usize,
        has_parent: bool,
        q_open: &str,
        q_close: &str,
    ) -> io::Result<()> {
        let cols = if has_parent {
            format!(
                "{}id{}, {}name{}, {}value{}, {}description{}, {}parent_id{}",
                q_open, q_close, q_open, q_close, q_open, q_close, q_open, q_close, q_open, q_close
            )
        } else {
            format!(
                "{}id{}, {}name{}, {}value{}, {}description{}",
                q_open, q_close, q_open, q_close, q_open, q_close, q_open, q_close
            )
        };

        writeln!(
            w,
            "INSERT INTO {}{}{} ({}) VALUES",
            q_open, table_name, q_close, cols
        )?;

        for row_idx in batch_start..batch_end {
            let global_id = table_idx * self.config.rows_per_table + row_idx + 1;
            let name = self.random_string(20);
            let value = self.rng.gen_range(1..=1_000_000);
            let desc = self.random_string(50);

            let formatted_name = self.format_string(&name);
            let formatted_desc = self.format_string(&desc);

            if has_parent {
                let parent_id = self
                    .rng
                    .gen_range(1..=(table_idx * self.config.rows_per_table));
                write!(
                    w,
                    "({}, {}, {}, {}, {})",
                    global_id, formatted_name, value, formatted_desc, parent_id
                )?;
            } else {
                write!(
                    w,
                    "({}, {}, {}, {})",
                    global_id, formatted_name, value, formatted_desc
                )?;
            }

            if row_idx < batch_end - 1 {
                writeln!(w, ",")?;
            } else {
                writeln!(w, ";")?;
            }
        }

        Ok(())
    }

    fn write_copy_batch<W: Write>(
        &mut self,
        w: &mut W,
        table_name: &str,
        table_idx: usize,
        batch_start: usize,
        batch_end: usize,
        has_parent: bool,
    ) -> io::Result<()> {
        // For PostgreSQL COPY, we write one COPY block per table (not per batch)
        // So only write header on first batch
        if batch_start == 0 {
            let cols = if has_parent {
                "id, name, value, description, parent_id"
            } else {
                "id, name, value, description"
            };
            writeln!(w, "COPY {} ({}) FROM stdin;", table_name, cols)?;
        }

        for row_idx in batch_start..batch_end {
            let global_id = table_idx * self.config.rows_per_table + row_idx + 1;
            let name = self.random_string(20);
            let value = self.rng.gen_range(1..=1_000_000);
            let desc = self.random_string(50);

            // Escape for COPY format (tab-separated, backslash escapes)
            let escaped_name = self.escape_copy(&name);
            let escaped_desc = self.escape_copy(&desc);

            if has_parent {
                let parent_id = self
                    .rng
                    .gen_range(1..=(table_idx * self.config.rows_per_table));
                writeln!(
                    w,
                    "{}\t{}\t{}\t{}\t{}",
                    global_id, escaped_name, value, escaped_desc, parent_id
                )?;
            } else {
                writeln!(
                    w,
                    "{}\t{}\t{}\t{}",
                    global_id, escaped_name, value, escaped_desc
                )?;
            }
        }

        // Write COPY terminator on last batch
        if batch_end >= self.config.rows_per_table {
            writeln!(w, "\\.")?;
        }

        Ok(())
    }

    fn random_string(&mut self, len: usize) -> String {
        (0..len)
            .map(|_| {
                let idx = self.rng.gen_range(0..CHARS.len());
                CHARS[idx] as char
            })
            .collect()
    }

    fn escape_string(&self, s: &str) -> String {
        match self.config.dialect {
            Dialect::MySql => s
                .replace('\\', "\\\\")
                .replace('\'', "\\'")
                .replace('\n', "\\n")
                .replace('\r', "\\r")
                .replace('\t', "\\t"),
            Dialect::Postgres | Dialect::Sqlite | Dialect::Mssql => s.replace('\'', "''"),
        }
    }

    fn format_string(&self, s: &str) -> String {
        let escaped = self.escape_string(s);
        match self.config.dialect {
            Dialect::Mssql => format!("N'{}'", escaped),
            _ => format!("'{}'", escaped),
        }
    }

    fn escape_copy(&self, s: &str) -> String {
        s.replace('\\', "\\\\")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t")
    }

    fn quote_chars(&self) -> (&'static str, &'static str) {
        match self.config.dialect {
            Dialect::MySql => ("`", "`"),
            Dialect::Postgres | Dialect::Sqlite => ("\"", "\""),
            Dialect::Mssql => ("[", "]"),
        }
    }
}

// ============================================================================
// Multi-Tenant Streaming Generator
// ============================================================================

/// Configuration for streaming multi-tenant generation
#[derive(Debug, Clone)]
pub struct MultiTenantConfig {
    pub dialect: Dialect,
    pub scale: Scale,
    pub seed: u64,
    pub batch_size: usize,
    pub include_schema: bool,
    /// Use GO batch separators for MSSQL
    pub use_go_separator: bool,
    /// Use [dbo]. schema prefix for MSSQL
    pub use_schema_prefix: bool,
    /// Use named CONSTRAINT syntax for MSSQL
    pub use_named_constraints: bool,
}

impl Default for MultiTenantConfig {
    fn default() -> Self {
        Self {
            dialect: Dialect::MySql,
            scale: Scale::Small,
            seed: 12345,
            batch_size: 100,
            include_schema: true,
            use_go_separator: false,
            use_schema_prefix: false,
            use_named_constraints: false,
        }
    }
}

/// ID tracker for FK relationships (only stores IDs, not row data)
#[derive(Debug, Default)]
struct IdTracker {
    ids: HashMap<String, Vec<i64>>,
    next_id: HashMap<String, i64>,
}

impl IdTracker {
    fn new() -> Self {
        Self::default()
    }

    fn next_id(&mut self, table: &str) -> i64 {
        let id = self.next_id.entry(table.to_string()).or_insert(1);
        let current = *id;
        *id += 1;
        self.ids.entry(table.to_string()).or_default().push(current);
        current
    }

    fn get_ids(&self, table: &str) -> &[i64] {
        self.ids.get(table).map(|v| v.as_slice()).unwrap_or(&[])
    }
}

/// Streaming multi-tenant generator
pub struct MultiTenantGenerator {
    config: MultiTenantConfig,
    fake: FakeData<ChaCha8Rng>,
    ids: IdTracker,
    /// Maps table_name -> tenant_id -> list of IDs for that tenant
    tenant_ids: HashMap<String, HashMap<i64, Vec<i64>>>,
}

impl MultiTenantGenerator {
    pub fn new(config: MultiTenantConfig) -> Self {
        let fake_rng = ChaCha8Rng::seed_from_u64(config.seed);
        Self {
            config,
            fake: FakeData::new(fake_rng),
            ids: IdTracker::new(),
            tenant_ids: HashMap::new(),
        }
    }

    /// Generate SQL and write directly to the writer (streaming)
    pub fn generate<W: Write>(&mut self, writer: W) -> io::Result<()> {
        let mut w = BufWriter::with_capacity(256 * 1024, writer);

        self.write_header(&mut w)?;

        if self.config.include_schema {
            self.write_all_schemas(&mut w)?;
        }

        self.write_all_data(&mut w)?;

        self.write_footer(&mut w)?;

        w.flush()
    }

    fn write_header<W: Write>(&self, w: &mut W) -> io::Result<()> {
        match self.config.dialect {
            Dialect::MySql => {
                writeln!(w, "-- Generated by test_data_gen (streaming multi-tenant)")?;
                writeln!(w, "-- Scale: {:?}", self.config.scale)?;
                writeln!(w)?;
                writeln!(w, "SET NAMES utf8mb4;")?;
                writeln!(w, "SET FOREIGN_KEY_CHECKS = 0;")?;
                writeln!(w)?;
            }
            Dialect::Postgres => {
                writeln!(w, "-- Generated by test_data_gen (streaming multi-tenant)")?;
                writeln!(w, "-- Scale: {:?}", self.config.scale)?;
                writeln!(w)?;
                writeln!(w, "SET client_encoding = 'UTF8';")?;
                writeln!(w)?;
            }
            Dialect::Sqlite => {
                writeln!(w, "-- Generated by test_data_gen (streaming multi-tenant)")?;
                writeln!(w, "-- Scale: {:?}", self.config.scale)?;
                writeln!(w)?;
                writeln!(w, "PRAGMA foreign_keys = OFF;")?;
                writeln!(w)?;
            }
            Dialect::Mssql => {
                writeln!(w, "-- Generated by test_data_gen (streaming multi-tenant)")?;
                writeln!(w, "-- Scale: {:?}", self.config.scale)?;
                writeln!(w)?;
                if self.config.use_go_separator {
                    writeln!(w, "SET ANSI_NULLS ON")?;
                    writeln!(w, "GO")?;
                    writeln!(w, "SET QUOTED_IDENTIFIER ON")?;
                    writeln!(w, "GO")?;
                    writeln!(w, "SET NOCOUNT ON")?;
                    writeln!(w, "GO")?;
                } else {
                    writeln!(w, "SET ANSI_NULLS ON;")?;
                    writeln!(w, "SET QUOTED_IDENTIFIER ON;")?;
                    writeln!(w, "SET NOCOUNT ON;")?;
                }
                writeln!(w)?;
            }
        }
        Ok(())
    }

    fn write_footer<W: Write>(&self, w: &mut W) -> io::Result<()> {
        writeln!(w)?;
        match self.config.dialect {
            Dialect::MySql => writeln!(w, "SET FOREIGN_KEY_CHECKS = 1;")?,
            Dialect::Postgres | Dialect::Mssql => {}
            Dialect::Sqlite => writeln!(w, "PRAGMA foreign_keys = ON;")?,
        }
        Ok(())
    }

    fn write_all_schemas<W: Write>(&self, w: &mut W) -> io::Result<()> {
        let (q_open, q_close) = self.quote_chars();

        writeln!(w, "-- ==============================================")?;
        writeln!(w, "-- Schema")?;
        writeln!(w, "-- ==============================================")?;
        writeln!(w)?;

        // Define all tables with their schemas
        let schemas = self.get_table_schemas();
        for (table_name, columns, pk_def) in schemas {
            let table_ref = self.format_table_name(table_name);
            writeln!(w, "CREATE TABLE {} (", table_ref)?;

            // Check if we should use named constraints
            let has_id_col = columns
                .first()
                .map(|(name, _)| *name == "id")
                .unwrap_or(false);
            let use_named_pk = self.config.use_named_constraints
                && self.config.dialect == Dialect::Mssql
                && has_id_col;

            for (i, (col_name, col_type)) in columns.iter().enumerate() {
                let is_last = i == columns.len() - 1;

                // For MSSQL with named constraints, strip inline PRIMARY KEY
                let col_type_adj = if use_named_pk && *col_name == "id" {
                    col_type.replace(" PRIMARY KEY", "")
                } else {
                    col_type.to_string()
                };

                let comma = if !is_last || !pk_def.is_empty() || use_named_pk {
                    ","
                } else {
                    ""
                };
                writeln!(
                    w,
                    "  {}{}{} {}{}",
                    q_open, col_name, q_close, col_type_adj, comma
                )?;
            }

            if use_named_pk {
                writeln!(
                    w,
                    "  CONSTRAINT {}PK_{}{} PRIMARY KEY CLUSTERED ({}id{})",
                    q_open, table_name, q_close, q_open, q_close
                )?;
            } else if !pk_def.is_empty() {
                writeln!(w, "  {}", pk_def)?;
            }

            write!(w, ")")?;
            if self.config.dialect == Dialect::Mssql && self.config.use_schema_prefix {
                write!(w, " ON [PRIMARY]")?;
            }
            writeln!(w, ";")?;

            if self.config.use_go_separator {
                writeln!(w, "GO")?;
            }
            writeln!(w)?;
        }

        Ok(())
    }

    /// Format a table name with optional schema prefix
    fn format_table_name(&self, table_name: &str) -> String {
        let (q_open, q_close) = self.quote_chars();
        if self.config.use_schema_prefix && self.config.dialect == Dialect::Mssql {
            format!("[dbo].{}{}{}", q_open, table_name, q_close)
        } else {
            format!("{}{}{}", q_open, table_name, q_close)
        }
    }

    #[allow(clippy::type_complexity)]
    fn get_table_schemas(
        &self,
    ) -> Vec<(
        &'static str,
        Vec<(&'static str, &'static str)>,
        &'static str,
    )> {
        let int_pk = match self.config.dialect {
            Dialect::MySql => "INT AUTO_INCREMENT PRIMARY KEY",
            Dialect::Postgres => "SERIAL PRIMARY KEY",
            Dialect::Sqlite => "INTEGER PRIMARY KEY AUTOINCREMENT",
            Dialect::Mssql => "INT IDENTITY(1,1) NOT NULL PRIMARY KEY",
        };
        let int_type = match self.config.dialect {
            Dialect::MySql | Dialect::Mssql => "INT",
            Dialect::Postgres | Dialect::Sqlite => "INTEGER",
        };
        let bool_type = match self.config.dialect {
            Dialect::MySql => "TINYINT(1)",
            Dialect::Postgres => "BOOLEAN",
            Dialect::Sqlite => "INTEGER",
            Dialect::Mssql => "BIT",
        };
        let decimal_type = match self.config.dialect {
            Dialect::MySql | Dialect::Postgres | Dialect::Mssql => "DECIMAL(10,2)",
            Dialect::Sqlite => "REAL",
        };
        let datetime_type = match self.config.dialect {
            Dialect::MySql => "DATETIME",
            Dialect::Postgres => "TIMESTAMP",
            Dialect::Sqlite => "TEXT",
            Dialect::Mssql => "DATETIME2",
        };
        let text_type = match self.config.dialect {
            Dialect::Mssql => "NVARCHAR(MAX)",
            _ => "TEXT",
        };

        let varchar_3 = if self.config.dialect == Dialect::Mssql {
            "NVARCHAR(3)"
        } else {
            "VARCHAR(3)"
        };
        let varchar_5 = if self.config.dialect == Dialect::Mssql {
            "NVARCHAR(5)"
        } else {
            "VARCHAR(5)"
        };
        let varchar_20 = if self.config.dialect == Dialect::Mssql {
            "NVARCHAR(20)"
        } else {
            "VARCHAR(20)"
        };
        let varchar_50 = if self.config.dialect == Dialect::Mssql {
            "NVARCHAR(50)"
        } else {
            "VARCHAR(50)"
        };
        let varchar_100 = if self.config.dialect == Dialect::Mssql {
            "NVARCHAR(100)"
        } else {
            "VARCHAR(100)"
        };
        let varchar_255 = if self.config.dialect == Dialect::Mssql {
            "NVARCHAR(255)"
        } else {
            "VARCHAR(255)"
        };
        let varchar_1000 = if self.config.dialect == Dialect::Mssql {
            "NVARCHAR(1000)"
        } else {
            "VARCHAR(1000)"
        };

        vec![
            (
                "permissions",
                vec![
                    ("id", int_pk),
                    ("name", varchar_100),
                    ("description", text_type),
                ],
                "",
            ),
            (
                "roles",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("name", varchar_100),
                    ("is_system", bool_type),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "role_permissions",
                vec![("role_id", int_type), ("permission_id", int_type)],
                "PRIMARY KEY (role_id, permission_id)",
            ),
            (
                "currencies",
                vec![
                    ("id", int_pk),
                    ("code", varchar_3),
                    ("name", varchar_50),
                    ("symbol", varchar_5),
                ],
                "",
            ),
            (
                "tenants",
                vec![
                    ("id", int_pk),
                    ("name", varchar_255),
                    ("slug", varchar_100),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "users",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("email", varchar_255),
                    ("name", varchar_255),
                    ("role", varchar_50),
                    ("active", bool_type),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "user_roles",
                vec![("user_id", int_type), ("role_id", int_type)],
                "PRIMARY KEY (user_id, role_id)",
            ),
            (
                "categories",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("parent_id", int_type),
                    ("name", varchar_100),
                    ("level", int_type),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "products",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("category_id", int_type),
                    ("sku", varchar_50),
                    ("name", varchar_255),
                    ("price", decimal_type),
                    ("active", bool_type),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "customers",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("name", varchar_255),
                    ("email", varchar_255),
                    ("phone", varchar_50),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "orders",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("customer_id", int_type),
                    ("order_number", varchar_50),
                    ("status", varchar_20),
                    ("total", decimal_type),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "order_items",
                vec![
                    ("id", int_pk),
                    ("order_id", int_type),
                    ("product_id", int_type),
                    ("quantity", int_type),
                    ("unit_price", decimal_type),
                ],
                "",
            ),
            (
                "projects",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("owner_id", int_type),
                    ("name", varchar_255),
                    ("status", varchar_20),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "tasks",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("project_id", int_type),
                    ("assignee_id", int_type),
                    ("title", varchar_255),
                    ("priority", int_type),
                    ("completed", bool_type),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "folders",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("parent_id", int_type),
                    ("name", varchar_255),
                    ("path", varchar_1000),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
            (
                "comments",
                vec![
                    ("id", int_pk),
                    ("tenant_id", int_type),
                    ("parent_id", int_type),
                    ("user_id", int_type),
                    ("commentable_type", varchar_50),
                    ("commentable_id", int_type),
                    ("body", text_type),
                    ("created_at", datetime_type),
                    ("updated_at", datetime_type),
                ],
                "",
            ),
        ]
    }

    fn write_all_data<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        writeln!(w, "-- ==============================================")?;
        writeln!(w, "-- Data")?;
        writeln!(w, "-- ==============================================")?;
        writeln!(w)?;

        // Generate global tables first
        self.write_permissions(w)?;
        self.write_roles_global(w)?;
        self.write_role_permissions(w)?;
        self.write_currencies(w)?;
        self.write_tenants(w)?;

        // Get tenant IDs for per-tenant data generation
        let tenant_ids: Vec<i64> = self.ids.get_ids("tenants").to_vec();

        // Generate per-tenant data for each table (all tenants per table)
        self.write_users(w, &tenant_ids)?;
        self.write_user_roles(w, &tenant_ids)?;
        self.write_categories(w, &tenant_ids)?;
        self.write_products(w, &tenant_ids)?;
        self.write_customers(w, &tenant_ids)?;
        self.write_orders(w, &tenant_ids)?;
        self.write_order_items(w, &tenant_ids)?;
        self.write_projects(w, &tenant_ids)?;
        self.write_tasks(w, &tenant_ids)?;
        self.write_folders(w, &tenant_ids)?;
        self.write_comments(w, &tenant_ids)?;

        Ok(())
    }

    fn write_permissions<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        let perms = FakeData::<ChaCha8Rng>::all_permissions();

        writeln!(w, "-- Table: permissions ({} rows)", perms.len())?;
        writeln!(
            w,
            "INSERT INTO {} ({}, {}, {}) VALUES",
            self.quote_ident("permissions"),
            self.quote_ident("id"),
            self.quote_ident("name"),
            self.quote_ident("description")
        )?;

        for (i, name) in perms.iter().enumerate() {
            let id = self.ids.next_id("permissions");
            let desc = format!("Permission to {}", name.replace('.', " "));
            let comma = if i < perms.len() - 1 { "," } else { ";" };
            writeln!(
                w,
                "({}, {}, {}){}",
                id,
                self.format_string(name),
                self.format_string(&desc),
                comma
            )?;
        }
        writeln!(w)?;
        Ok(())
    }

    fn write_roles_global<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        let roles = FakeData::<ChaCha8Rng>::all_roles();

        writeln!(w, "-- Table: roles ({} rows)", roles.len())?;
        writeln!(
            w,
            "INSERT INTO {} ({}, {}, {}, {}, {}, {}) VALUES",
            self.quote_ident("roles"),
            self.quote_ident("id"),
            self.quote_ident("tenant_id"),
            self.quote_ident("name"),
            self.quote_ident("is_system"),
            self.quote_ident("created_at"),
            self.quote_ident("updated_at")
        )?;

        for (i, name) in roles.iter().enumerate() {
            let id = self.ids.next_id("roles");
            let created = self.fake.datetime(2020, 2024);
            let bool_val = self.format_bool(true);
            let comma = if i < roles.len() - 1 { "," } else { ";" };
            writeln!(
                w,
                "({}, NULL, {}, {}, {}, {}){}",
                id,
                self.format_string(name),
                bool_val,
                self.format_string(&created),
                self.format_string(&created),
                comma
            )?;
        }
        writeln!(w)?;
        Ok(())
    }

    fn write_role_permissions<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        let role_ids = self.ids.get_ids("roles").to_vec();
        let perm_ids = self.ids.get_ids("permissions").to_vec();

        let mut rows = Vec::new();

        // Admin role gets all permissions
        if let Some(&admin_role) = role_ids.first() {
            for &perm_id in &perm_ids {
                rows.push((admin_role, perm_id));
            }
        }
        // Other roles get subset
        for &role_id in role_ids.iter().skip(1) {
            let count = self.fake.int_range(2, 5) as usize;
            for &perm_id in perm_ids.iter().take(count.min(perm_ids.len())) {
                rows.push((role_id, perm_id));
            }
        }

        if rows.is_empty() {
            return Ok(());
        }

        writeln!(w, "-- Table: role_permissions ({} rows)", rows.len())?;
        writeln!(
            w,
            "INSERT INTO {} ({}, {}) VALUES",
            self.quote_ident("role_permissions"),
            self.quote_ident("role_id"),
            self.quote_ident("permission_id")
        )?;

        for (i, (role_id, perm_id)) in rows.iter().enumerate() {
            let comma = if i < rows.len() - 1 { "," } else { ";" };
            writeln!(w, "({}, {}){}", role_id, perm_id, comma)?;
        }
        writeln!(w)?;
        Ok(())
    }

    fn write_currencies<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        let currencies = [
            ("USD", "US Dollar", "$"),
            ("EUR", "Euro", "€"),
            ("GBP", "British Pound", "£"),
            ("JPY", "Japanese Yen", "¥"),
            ("CAD", "Canadian Dollar", "C$"),
        ];

        writeln!(w, "-- Table: currencies ({} rows)", currencies.len())?;
        writeln!(
            w,
            "INSERT INTO {} ({}, {}, {}, {}) VALUES",
            self.quote_ident("currencies"),
            self.quote_ident("id"),
            self.quote_ident("code"),
            self.quote_ident("name"),
            self.quote_ident("symbol")
        )?;

        for (i, (code, name, symbol)) in currencies.iter().enumerate() {
            let id = self.ids.next_id("currencies");
            let comma = if i < currencies.len() - 1 { "," } else { ";" };
            writeln!(
                w,
                "({}, {}, {}, {}){}",
                id,
                self.format_string(code),
                self.format_string(name),
                self.format_string(symbol),
                comma
            )?;
        }
        writeln!(w)?;
        Ok(())
    }

    fn write_tenants<W: Write>(&mut self, w: &mut W) -> io::Result<()> {
        let count = self.config.scale.tenants();

        writeln!(w, "-- Table: tenants ({} rows)", count)?;
        writeln!(
            w,
            "INSERT INTO {} ({}, {}, {}, {}, {}) VALUES",
            self.quote_ident("tenants"),
            self.quote_ident("id"),
            self.quote_ident("name"),
            self.quote_ident("slug"),
            self.quote_ident("created_at"),
            self.quote_ident("updated_at")
        )?;

        for i in 0..count {
            let id = self.ids.next_id("tenants");
            let name = self.fake.company_name();
            let slug = self.fake.slug(&name);
            let created = self.fake.datetime(2020, 2024);
            let comma = if i < count - 1 { "," } else { ";" };
            writeln!(
                w,
                "({}, {}, {}, {}, {}){}",
                id,
                self.format_string(&name),
                self.format_string(&slug),
                self.format_string(&created),
                self.format_string(&created),
                comma
            )?;
        }
        writeln!(w)?;
        Ok(())
    }

    fn write_users<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let users_per_tenant = self.config.scale.users_per_tenant();
        let total_rows = users_per_tenant * tenant_ids.len();

        writeln!(w, "-- Table: users ({} rows)", total_rows)?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let mut user_ids_for_tenant = Vec::new();

            for _ in 0..users_per_tenant {
                let id = self.ids.next_id("users");
                user_ids_for_tenant.push(id);

                let first = self.fake.first_name();
                let last = self.fake.last_name();
                let email = self.fake.email(first, last, "example.com");
                let name = format!("{} {}", first, last);
                let role = self.fake.role();
                let is_active = self.fake.bool_with_probability(0.9);
                let active = self.format_bool(is_active);
                let created = self.fake.datetime(2020, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {}, {}, {})",
                    id,
                    tenant_id,
                    self.format_string(&email),
                    self.format_string(&name),
                    self.format_string(role),
                    active,
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "users",
                        &[
                            "id",
                            "tenant_id",
                            "email",
                            "name",
                            "role",
                            "active",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }

            self.tenant_ids
                .entry("users".to_string())
                .or_default()
                .insert(tenant_id, user_ids_for_tenant);
        }

        self.flush_batch(
            w,
            "users",
            &[
                "id",
                "tenant_id",
                "email",
                "name",
                "role",
                "active",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_user_roles<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let role_ids = self.ids.get_ids("roles").to_vec();

        if role_ids.is_empty() {
            return Ok(());
        }

        let mut rows = Vec::new();
        for &tenant_id in tenant_ids {
            if let Some(user_ids) = self.tenant_ids.get("users").and_then(|m| m.get(&tenant_id)) {
                for &user_id in user_ids {
                    let role_id =
                        role_ids[self.fake.int_range(0, (role_ids.len() - 1) as i64) as usize];
                    rows.push((user_id, role_id));
                }
            }
        }

        if rows.is_empty() {
            return Ok(());
        }

        writeln!(w, "-- Table: user_roles ({} rows)", rows.len())?;
        writeln!(
            w,
            "INSERT INTO {} ({}, {}) VALUES",
            self.quote_ident("user_roles"),
            self.quote_ident("user_id"),
            self.quote_ident("role_id")
        )?;

        for (i, (user_id, role_id)) in rows.iter().enumerate() {
            let comma = if i < rows.len() - 1 { "," } else { ";" };
            writeln!(w, "({}, {}){}", user_id, role_id, comma)?;
        }
        writeln!(w)?;
        Ok(())
    }

    fn write_categories<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let cats_per_tenant = self.config.scale.categories_per_tenant();
        let total = cats_per_tenant * tenant_ids.len();

        writeln!(w, "-- Table: categories ({} rows)", total)?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let mut cat_ids = Vec::new();

            for i in 0..cats_per_tenant {
                let id = self.ids.next_id("categories");
                cat_ids.push(id);

                let parent_id = if i < 3 || cat_ids.len() <= 1 {
                    "NULL".to_string()
                } else {
                    let parent_idx = self.fake.int_range(0, (cat_ids.len() - 2) as i64) as usize;
                    cat_ids[parent_idx].to_string()
                };

                let name = self.fake.category();
                let level = if parent_id == "NULL" { 0 } else { 1 };
                let created = self.fake.datetime(2020, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {}, {})",
                    id,
                    tenant_id,
                    parent_id,
                    self.format_string(name),
                    level,
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "categories",
                        &[
                            "id",
                            "tenant_id",
                            "parent_id",
                            "name",
                            "level",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }

            self.tenant_ids
                .entry("categories".to_string())
                .or_default()
                .insert(tenant_id, cat_ids);
        }

        self.flush_batch(
            w,
            "categories",
            &[
                "id",
                "tenant_id",
                "parent_id",
                "name",
                "level",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_products<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let prods_per_tenant = self.config.scale.products_per_tenant();
        let total = prods_per_tenant * tenant_ids.len();

        writeln!(w, "-- Table: products ({} rows)", total)?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let cat_ids = self
                .tenant_ids
                .get("categories")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let mut prod_ids = Vec::new();

            for _ in 0..prods_per_tenant {
                let id = self.ids.next_id("products");
                prod_ids.push(id);

                let cat_id = if cat_ids.is_empty() {
                    "NULL".to_string()
                } else {
                    cat_ids[self.fake.int_range(0, (cat_ids.len() - 1) as i64) as usize].to_string()
                };

                let sku = self.fake.sku();
                let name = self.fake.product_name();
                let price = self.fake.price(5.0, 500.0);
                let is_active = self.fake.bool_with_probability(0.85);
                let active = self.format_bool(is_active);
                let created = self.fake.datetime(2020, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {:.2}, {}, {}, {})",
                    id,
                    tenant_id,
                    cat_id,
                    self.format_string(&sku),
                    self.format_string(&name),
                    price,
                    active,
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "products",
                        &[
                            "id",
                            "tenant_id",
                            "category_id",
                            "sku",
                            "name",
                            "price",
                            "active",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }

            self.tenant_ids
                .entry("products".to_string())
                .or_default()
                .insert(tenant_id, prod_ids);
        }

        self.flush_batch(
            w,
            "products",
            &[
                "id",
                "tenant_id",
                "category_id",
                "sku",
                "name",
                "price",
                "active",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_customers<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let orders_per_tenant = self.config.scale.orders_per_tenant();
        let custs_per_tenant = (orders_per_tenant / 2).max(5);
        let total = custs_per_tenant * tenant_ids.len();

        writeln!(w, "-- Table: customers ({} rows)", total)?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let mut cust_ids = Vec::new();

            for _ in 0..custs_per_tenant {
                let id = self.ids.next_id("customers");
                cust_ids.push(id);

                let first = self.fake.first_name();
                let last = self.fake.last_name();
                let name = format!("{} {}", first, last);
                let email = self.fake.email(first, last, "customer.example.com");
                let phone = self.fake.phone();
                let created = self.fake.datetime(2020, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {}, {})",
                    id,
                    tenant_id,
                    self.format_string(&name),
                    self.format_string(&email),
                    self.format_string(&phone),
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "customers",
                        &[
                            "id",
                            "tenant_id",
                            "name",
                            "email",
                            "phone",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }

            self.tenant_ids
                .entry("customers".to_string())
                .or_default()
                .insert(tenant_id, cust_ids);
        }

        self.flush_batch(
            w,
            "customers",
            &[
                "id",
                "tenant_id",
                "name",
                "email",
                "phone",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_orders<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let orders_per_tenant = self.config.scale.orders_per_tenant();
        let total = orders_per_tenant * tenant_ids.len();

        writeln!(w, "-- Table: orders ({} rows)", total)?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let cust_ids = self
                .tenant_ids
                .get("customers")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let mut order_ids = Vec::new();

            for _ in 0..orders_per_tenant {
                let id = self.ids.next_id("orders");
                order_ids.push(id);

                let cust_id = if cust_ids.is_empty() {
                    "NULL".to_string()
                } else {
                    cust_ids[self.fake.int_range(0, (cust_ids.len() - 1) as i64) as usize]
                        .to_string()
                };

                let order_num = self.fake.order_number();
                let status = self.fake.order_status();
                let total_amt = self.fake.price(20.0, 2000.0);
                let created = self.fake.datetime(2023, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {:.2}, {}, {})",
                    id,
                    tenant_id,
                    cust_id,
                    self.format_string(&order_num),
                    self.format_string(status),
                    total_amt,
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "orders",
                        &[
                            "id",
                            "tenant_id",
                            "customer_id",
                            "order_number",
                            "status",
                            "total",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }

            self.tenant_ids
                .entry("orders".to_string())
                .or_default()
                .insert(tenant_id, order_ids);
        }

        self.flush_batch(
            w,
            "orders",
            &[
                "id",
                "tenant_id",
                "customer_id",
                "order_number",
                "status",
                "total",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_order_items<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        writeln!(w, "-- Table: order_items")?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let order_ids = self
                .tenant_ids
                .get("orders")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let prod_ids = self
                .tenant_ids
                .get("products")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();

            if prod_ids.is_empty() {
                continue;
            }

            for &order_id in &order_ids {
                let item_count = self.fake.int_range(1, 5) as usize;
                for _ in 0..item_count {
                    let id = self.ids.next_id("order_items");
                    let prod_id =
                        prod_ids[self.fake.int_range(0, (prod_ids.len() - 1) as i64) as usize];
                    let qty = self.fake.int_range(1, 10);
                    let price = self.fake.price(5.0, 200.0);

                    batch.push(format!(
                        "({}, {}, {}, {}, {:.2})",
                        id, order_id, prod_id, qty, price
                    ));

                    if batch.len() >= self.config.batch_size {
                        self.flush_batch(
                            w,
                            "order_items",
                            &["id", "order_id", "product_id", "quantity", "unit_price"],
                            &mut batch,
                            &mut first_batch,
                        )?;
                    }
                }
            }
        }

        self.flush_batch(
            w,
            "order_items",
            &["id", "order_id", "product_id", "quantity", "unit_price"],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_projects<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let projs_per_tenant = self.config.scale.projects_per_tenant();
        let total = projs_per_tenant * tenant_ids.len();

        writeln!(w, "-- Table: projects ({} rows)", total)?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let user_ids = self
                .tenant_ids
                .get("users")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let mut proj_ids = Vec::new();

            for _ in 0..projs_per_tenant {
                let id = self.ids.next_id("projects");
                proj_ids.push(id);

                let owner_id = if user_ids.is_empty() {
                    "NULL".to_string()
                } else {
                    user_ids[self.fake.int_range(0, (user_ids.len() - 1) as i64) as usize]
                        .to_string()
                };

                let name = format!("Project {}", self.fake.product_name());
                let status = self.fake.project_status();
                let created = self.fake.datetime(2022, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {}, {})",
                    id,
                    tenant_id,
                    owner_id,
                    self.format_string(&name),
                    self.format_string(status),
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "projects",
                        &[
                            "id",
                            "tenant_id",
                            "owner_id",
                            "name",
                            "status",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }

            self.tenant_ids
                .entry("projects".to_string())
                .or_default()
                .insert(tenant_id, proj_ids);
        }

        self.flush_batch(
            w,
            "projects",
            &[
                "id",
                "tenant_id",
                "owner_id",
                "name",
                "status",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_tasks<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let tasks_per_project = self.config.scale.tasks_per_project();

        writeln!(w, "-- Table: tasks")?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let proj_ids = self
                .tenant_ids
                .get("projects")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let user_ids = self
                .tenant_ids
                .get("users")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let mut task_ids = Vec::new();

            for &proj_id in &proj_ids {
                for _ in 0..tasks_per_project {
                    let id = self.ids.next_id("tasks");
                    task_ids.push(id);

                    let assignee_id = if user_ids.is_empty() || self.fake.bool_with_probability(0.2)
                    {
                        "NULL".to_string()
                    } else {
                        user_ids[self.fake.int_range(0, (user_ids.len() - 1) as i64) as usize]
                            .to_string()
                    };

                    let title = self.fake.sentence(4);
                    let priority = self.fake.task_priority();
                    let is_completed = self.fake.bool_with_probability(0.3);
                    let completed = self.format_bool(is_completed);
                    let created = self.fake.datetime(2023, 2024);

                    batch.push(format!(
                        "({}, {}, {}, {}, {}, {}, {}, {}, {})",
                        id,
                        tenant_id,
                        proj_id,
                        assignee_id,
                        self.format_string(&title),
                        priority,
                        completed,
                        self.format_string(&created),
                        self.format_string(&created)
                    ));

                    if batch.len() >= self.config.batch_size {
                        self.flush_batch(
                            w,
                            "tasks",
                            &[
                                "id",
                                "tenant_id",
                                "project_id",
                                "assignee_id",
                                "title",
                                "priority",
                                "completed",
                                "created_at",
                                "updated_at",
                            ],
                            &mut batch,
                            &mut first_batch,
                        )?;
                    }
                }
            }

            self.tenant_ids
                .entry("tasks".to_string())
                .or_default()
                .insert(tenant_id, task_ids);
        }

        self.flush_batch(
            w,
            "tasks",
            &[
                "id",
                "tenant_id",
                "project_id",
                "assignee_id",
                "title",
                "priority",
                "completed",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_folders<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let folders_per_tenant = self.config.scale.folders_per_tenant();
        let total = folders_per_tenant * tenant_ids.len();

        writeln!(w, "-- Table: folders ({} rows)", total)?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let mut folder_ids = Vec::new();

            for i in 0..folders_per_tenant {
                let id = self.ids.next_id("folders");
                folder_ids.push(id);

                let parent_id = if i < 2 || folder_ids.len() <= 1 {
                    "NULL".to_string()
                } else {
                    let parent_idx = self.fake.int_range(0, (folder_ids.len() - 2) as i64) as usize;
                    folder_ids[parent_idx].to_string()
                };

                let name = self.fake.path_segment();
                let path = format!("/{}", name);
                let created = self.fake.datetime(2022, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {}, {})",
                    id,
                    tenant_id,
                    parent_id,
                    self.format_string(&name),
                    self.format_string(&path),
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "folders",
                        &[
                            "id",
                            "tenant_id",
                            "parent_id",
                            "name",
                            "path",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }
        }

        self.flush_batch(
            w,
            "folders",
            &[
                "id",
                "tenant_id",
                "parent_id",
                "name",
                "path",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    fn write_comments<W: Write>(&mut self, w: &mut W, tenant_ids: &[i64]) -> io::Result<()> {
        let comments_per_tenant = self.config.scale.comments_per_tenant();

        writeln!(w, "-- Table: comments")?;

        let mut batch = Vec::new();
        let mut first_batch = true;

        for &tenant_id in tenant_ids {
            let user_ids = self
                .tenant_ids
                .get("users")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let task_ids = self
                .tenant_ids
                .get("tasks")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();
            let proj_ids = self
                .tenant_ids
                .get("projects")
                .and_then(|m| m.get(&tenant_id))
                .cloned()
                .unwrap_or_default();

            let mut comment_ids = Vec::new();

            for i in 0..comments_per_tenant {
                let id = self.ids.next_id("comments");
                comment_ids.push(id);

                let parent_id =
                    if i < 3 || comment_ids.len() <= 1 || self.fake.bool_with_probability(0.6) {
                        "NULL".to_string()
                    } else {
                        let parent_idx =
                            self.fake.int_range(0, (comment_ids.len() - 2) as i64) as usize;
                        comment_ids[parent_idx].to_string()
                    };

                let user_id = if user_ids.is_empty() {
                    "NULL".to_string()
                } else {
                    user_ids[self.fake.int_range(0, (user_ids.len() - 1) as i64) as usize]
                        .to_string()
                };

                let (commentable_type, commentable_id) =
                    if self.fake.bool_with_probability(0.7) && !task_ids.is_empty() {
                        (
                            "task",
                            task_ids[self.fake.int_range(0, (task_ids.len() - 1) as i64) as usize],
                        )
                    } else if !proj_ids.is_empty() {
                        (
                            "project",
                            proj_ids[self.fake.int_range(0, (proj_ids.len() - 1) as i64) as usize],
                        )
                    } else {
                        continue;
                    };

                let body = self.fake.paragraph(2);
                let created = self.fake.datetime(2023, 2024);

                batch.push(format!(
                    "({}, {}, {}, {}, {}, {}, {}, {}, {})",
                    id,
                    tenant_id,
                    parent_id,
                    user_id,
                    self.format_string(commentable_type),
                    commentable_id,
                    self.format_string(&body),
                    self.format_string(&created),
                    self.format_string(&created)
                ));

                if batch.len() >= self.config.batch_size {
                    self.flush_batch(
                        w,
                        "comments",
                        &[
                            "id",
                            "tenant_id",
                            "parent_id",
                            "user_id",
                            "commentable_type",
                            "commentable_id",
                            "body",
                            "created_at",
                            "updated_at",
                        ],
                        &mut batch,
                        &mut first_batch,
                    )?;
                }
            }
        }

        self.flush_batch(
            w,
            "comments",
            &[
                "id",
                "tenant_id",
                "parent_id",
                "user_id",
                "commentable_type",
                "commentable_id",
                "body",
                "created_at",
                "updated_at",
            ],
            &mut batch,
            &mut first_batch,
        )?;

        writeln!(w)?;
        Ok(())
    }

    // Helper methods
    fn flush_batch<W: Write>(
        &self,
        w: &mut W,
        table_name: &str,
        columns: &[&str],
        batch: &mut Vec<String>,
        first_batch: &mut bool,
    ) -> io::Result<()> {
        if batch.is_empty() {
            return Ok(());
        }

        let cols_str = columns
            .iter()
            .map(|c| self.quote_ident(c))
            .collect::<Vec<_>>()
            .join(", ");
        let table_ref = self.format_table_name(table_name);

        writeln!(w, "INSERT INTO {} ({}) VALUES", table_ref, cols_str)?;
        writeln!(w, "{};", batch.join(",\n"))?;

        if self.config.use_go_separator {
            writeln!(w, "GO")?;
        }

        batch.clear();
        *first_batch = false;
        Ok(())
    }

    fn escape_string(&self, s: &str) -> String {
        match self.config.dialect {
            Dialect::MySql => s
                .replace('\\', "\\\\")
                .replace('\'', "\\'")
                .replace('\n', "\\n")
                .replace('\r', "\\r")
                .replace('\t', "\\t"),
            Dialect::Postgres | Dialect::Sqlite | Dialect::Mssql => s.replace('\'', "''"),
        }
    }

    fn format_string(&self, s: &str) -> String {
        let escaped = self.escape_string(s);
        match self.config.dialect {
            Dialect::Mssql => format!("N'{}'", escaped),
            _ => format!("'{}'", escaped),
        }
    }

    fn format_bool(&self, b: bool) -> &'static str {
        match self.config.dialect {
            Dialect::MySql | Dialect::Sqlite | Dialect::Mssql => {
                if b {
                    "1"
                } else {
                    "0"
                }
            }
            Dialect::Postgres => {
                if b {
                    "TRUE"
                } else {
                    "FALSE"
                }
            }
        }
    }

    fn quote_chars(&self) -> (&'static str, &'static str) {
        match self.config.dialect {
            Dialect::MySql => ("`", "`"),
            Dialect::Postgres | Dialect::Sqlite => ("\"", "\""),
            Dialect::Mssql => ("[", "]"),
        }
    }

    fn quote_ident(&self, name: &str) -> String {
        let (q_open, q_close) = self.quote_chars();
        format!("{}{}{}", q_open, name, q_close)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_streaming_deterministic() {
        let config = StreamingConfig {
            rows_per_table: 10,
            num_tables: 2,
            seed: 42,
            ..Default::default()
        };

        let mut gen1 = StreamingGenerator::new(config.clone());
        let mut gen2 = StreamingGenerator::new(config);

        let mut out1 = Vec::new();
        let mut out2 = Vec::new();

        gen1.generate(&mut out1).unwrap();
        gen2.generate(&mut out2).unwrap();

        assert_eq!(out1, out2);
    }

    #[test]
    fn test_streaming_mysql() {
        let config = StreamingConfig {
            dialect: Dialect::MySql,
            rows_per_table: 5,
            num_tables: 2,
            seed: 42,
            batch_size: 100,
            ..Default::default()
        };

        let mut gen = StreamingGenerator::new(config);
        let mut out = Vec::new();
        gen.generate(&mut out).unwrap();

        let sql = String::from_utf8(out).unwrap();
        assert!(sql.contains("SET NAMES utf8mb4;"));
        assert!(sql.contains("CREATE TABLE `table_000`"));
        assert!(sql.contains("INSERT INTO `table_000`"));
        assert!(sql.contains("`parent_id`")); // table_001 has FK
    }

    #[test]
    fn test_streaming_postgres() {
        let config = StreamingConfig {
            dialect: Dialect::Postgres,
            rows_per_table: 5,
            num_tables: 2,
            seed: 42,
            ..Default::default()
        };

        let mut gen = StreamingGenerator::new(config);
        let mut out = Vec::new();
        gen.generate(&mut out).unwrap();

        let sql = String::from_utf8(out).unwrap();
        assert!(sql.contains("SET client_encoding"));
        assert!(sql.contains("COPY table_000"));
        assert!(sql.contains("\\."));
    }

    #[test]
    fn test_streaming_mssql() {
        let config = StreamingConfig {
            dialect: Dialect::Mssql,
            rows_per_table: 5,
            num_tables: 2,
            seed: 42,
            batch_size: 100,
            ..Default::default()
        };

        let mut gen = StreamingGenerator::new(config);
        let mut out = Vec::new();
        gen.generate(&mut out).unwrap();

        let sql = String::from_utf8(out).unwrap();
        assert!(sql.contains("SET ANSI_NULLS ON;"));
        assert!(sql.contains("CREATE TABLE [table_000]"));
        assert!(sql.contains("INT IDENTITY(1,1)"));
        assert!(sql.contains("INSERT INTO [table_000]"));
        assert!(sql.contains("N'")); // Unicode string literals
        assert!(sql.contains("[parent_id]")); // table_001 has FK
    }
}
