<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sql-splitter - High-Performance SQL File Splitter in Rust</title>
    <meta name="description" content="Split large SQL dump files into individual table files at 400+ MB/s. Memory-efficient, streaming architecture handles gigabyte-scale files. Written in Rust.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Monda:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav>
        <div class="nav-content">
            <a href="#" class="logo">
                <span class="logo-icon">;</span>
                sql-splitter
            </a>
            <div class="nav-links">
                <a href="#install">Install</a>
                <a href="#guide">Guide</a>
                <a href="https://github.com/helgesverre/sql-splitter" target="_blank">GitHub</a>
            </div>
        </div>
    </nav>

    <main>
        <!-- Hero -->
        <section class="hero">
            <h1>
                <span class="logo-icon">;</span>
                sql-splitter
            </h1>
            <p class="subtitle">Split SQL dumps at 400+ MB/s</p>
            <p class="description">
                High-performance CLI tool for splitting large SQL dump files into individual
                table files. Supports MySQL, PostgreSQL, and SQLite. Written in Rust.
            </p>
            <div class="hero-actions">
                <a href="#install" class="btn btn-primary">Get Started</a>
                <a href="https://github.com/helgesverre/sql-splitter" class="btn btn-secondary" target="_blank">View on GitHub</a>
            </div>
        </section>

        <!-- Why -->
        <section class="why">
            <h2>Why sql-splitter?</h2>
            <p class="lead">
                Working with large SQL dumps is painful. Importing a 10GB file takes forever,
                and you often just need a few tables. sql-splitter lets you split the dump
                into individual files so you can import only what you need.
            </p>
            <div class="benefits">
                <div class="benefit">
                    <div class="benefit-icon">~</div>
                    <h3>Blazing Fast</h3>
                    <p>400+ MB/s throughput</p>
                </div>
                <div class="benefit">
                    <div class="benefit-icon">&lt;</div>
                    <h3>Memory Efficient</h3>
                    <p>~50MB constant usage</p>
                </div>
                <div class="benefit">
                    <div class="benefit-icon">*</div>
                    <h3>Zero-Copy</h3>
                    <p>No garbage collection</p>
                </div>
            </div>
        </section>

        <!-- Quick Start -->
        <section class="quickstart">
            <h2>Quick Start</h2>
            <p class="lead">Split a SQL file in seconds.</p>

            <div class="steps">
                <div class="step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h3>Build from source</h3>
                        <div class="code-block">
                            <pre><code>git clone https://github.com/helgesverre/sql-splitter.git
cd sql-splitter
cargo build --release</code></pre>
                            <button class="copy-btn" data-copy="git clone https://github.com/helgesverre/sql-splitter.git && cd sql-splitter && cargo build --release">Copy</button>
                        </div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h3>Split your dump</h3>
                        <div class="code-block">
                            <pre><code>./target/release/sql-splitter split database.sql --output=tables</code></pre>
                            <button class="copy-btn" data-copy="./target/release/sql-splitter split database.sql --output=tables">Copy</button>
                        </div>
                    </div>
                </div>
            </div>

            <p class="note">That's it! Each table gets its own .sql file in the output directory.</p>
        </section>

        <!-- Install -->
        <section id="install" class="install">
            <h2>Installation</h2>

            <h3>From crates.io (Recommended)</h3>
            <p>If you have Rust installed:</p>
            <div class="code-block">
                <pre><code>cargo install sql-splitter</code></pre>
                <button class="copy-btn" data-copy="cargo install sql-splitter">Copy</button>
            </div>

            <h3>From GitHub</h3>
            <div class="code-block">
                <pre><code>cargo install --git https://github.com/helgesverre/sql-splitter</code></pre>
                <button class="copy-btn" data-copy="cargo install --git https://github.com/helgesverre/sql-splitter">Copy</button>
            </div>

            <h3>Build from Source</h3>
            <div class="code-block">
                <pre><code>git clone https://github.com/helgesverre/sql-splitter.git
cd sql-splitter
cargo build --release
sudo cp target/release/sql-splitter /usr/local/bin/</code></pre>
                <button class="copy-btn" data-copy="git clone https://github.com/helgesverre/sql-splitter.git
cd sql-splitter
cargo build --release
sudo cp target/release/sql-splitter /usr/local/bin/">Copy</button>
            </div>

            <h3>Optimized Build (Best Performance)</h3>
            <p>Build with CPU-specific optimizations for maximum throughput:</p>
            <div class="code-block">
                <pre><code>RUSTFLAGS="-C target-cpu=native" cargo build --release</code></pre>
                <button class="copy-btn" data-copy="RUSTFLAGS=&quot;-C target-cpu=native&quot; cargo build --release">Copy</button>
            </div>

            <div class="verify">
                <p>Verify installation:</p>
                <div class="code-block">
                    <pre><code>sql-splitter --version</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter --version">Copy</button>
                </div>
            </div>
        </section>

        <!-- User Guide -->
        <section id="guide" class="guide">
            <h2>User Guide</h2>

            <!-- Commands -->
            <article class="guide-section">
                <h3>Commands</h3>

                <h4>split</h4>
                <p>Split a SQL dump file into individual table files.</p>
                <div class="code-block">
                    <pre><code># MySQL/MariaDB dump (default)
sql-splitter split database.sql --output=tables

# PostgreSQL pg_dump
sql-splitter split pg_dump.sql --output=tables --dialect=postgres

# SQLite dump
sql-splitter split sqlite.sql --output=tables --dialect=sqlite

# Split only specific tables
sql-splitter split database.sql --tables=users,posts

# Schema only (CREATE TABLE, indexes)
sql-splitter split database.sql --schema-only -o schema/

# Data only (INSERT/COPY statements)
sql-splitter split database.sql --data-only -o data/

# Batch with glob patterns
sql-splitter split "*.sql" -o output/ --fail-fast</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter split database.sql --output=tables">Copy</button>
                </div>

                <h4>merge</h4>
                <p>Merge split SQL files back into a single file.</p>
                <div class="code-block">
                    <pre><code># Merge all tables
sql-splitter merge tables/ -o restored.sql

# Merge with transaction wrapper
sql-splitter merge tables/ -o restored.sql --transaction

# Merge only specific tables
sql-splitter merge tables/ -o partial.sql --tables=users,orders

# Exclude specific tables
sql-splitter merge tables/ -o restored.sql --exclude=logs,cache</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter merge tables/ -o restored.sql">Copy</button>
                </div>

                <h4>analyze</h4>
                <p>Analyze a SQL file and display table statistics.</p>
                <div class="code-block">
                    <pre><code>sql-splitter analyze database.sql
sql-splitter analyze database.sql --progress
sql-splitter analyze "**/*.sql" --fail-fast</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter analyze database.sql">Copy</button>
                </div>

                <h4>validate</h4>
                <p>Check SQL dump integrity with comprehensive validation.</p>
                <div class="code-block">
                    <pre><code># Basic validation
sql-splitter validate dump.sql

# Strict mode for CI (warnings = errors)
sql-splitter validate dump.sql --strict --json

# Skip expensive PK/FK checks
sql-splitter validate dump.sql --no-fk-checks

# Batch validation
sql-splitter validate "*.sql" --fail-fast</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter validate dump.sql">Copy</button>
                </div>

                <h4>convert</h4>
                <p>Convert SQL dumps between MySQL, PostgreSQL, and SQLite.</p>
                <div class="code-block">
                    <pre><code># MySQL to PostgreSQL
sql-splitter convert mysql.sql --to postgres -o pg.sql

# PostgreSQL to MySQL (COPY â†’ INSERT)
sql-splitter convert pg_dump.sql --to mysql -o mysql.sql

# Auto-detect source, convert to SQLite
sql-splitter convert dump.sql --to sqlite -o sqlite.sql

# Explicit source dialect
sql-splitter convert dump.sql --from postgres --to mysql -o out.sql

# Strict mode (fail on unsupported features)
sql-splitter convert dump.sql --to postgres --strict -o out.sql

# Batch conversion
sql-splitter convert "*.sql" --to postgres -o converted/</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter convert mysql.sql --to postgres -o pg.sql">Copy</button>
                </div>

                <h4>sample</h4>
                <p>Create reduced datasets with FK preservation.</p>
                <div class="code-block">
                    <pre><code># Sample 10% of rows
sql-splitter sample dump.sql -o sampled.sql --percent 10

# Sample fixed rows per table
sql-splitter sample dump.sql -o sampled.sql --rows 1000

# Preserve FK relationships
sql-splitter sample dump.sql -o dev.sql --percent 10 --preserve-relations

# Reproducible sampling with seed
sql-splitter sample dump.sql -o dev.sql --percent 10 --seed 42</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter sample dump.sql -o sampled.sql --percent 10 --preserve-relations">Copy</button>
                </div>

                <h4>shard</h4>
                <p>Extract tenant-specific data from multi-tenant dumps.</p>
                <div class="code-block">
                    <pre><code># Extract single tenant
sql-splitter shard dump.sql --tenant-value 123 -o tenant_123.sql

# Auto-detect tenant column (tenant_id, company_id, etc.)
sql-splitter shard dump.sql --tenant-value 5 -o tenant.sql

# Explicit tenant column
sql-splitter shard dump.sql --tenant-column account_id --tenant-value 42 -o out.sql

# Extract multiple tenants
sql-splitter shard dump.sql --tenant-values "1,2,3" -o shards/</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter shard dump.sql --tenant-value 123 -o tenant_123.sql">Copy</button>
                </div>
            </article>

            <!-- Split Options -->
            <article class="guide-section">
                <h3>Split Options</h3>
                <table class="options-table">
                    <thead>
                        <tr><th>Flag</th><th>Short</th><th>Description</th><th>Default</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>--output</code></td><td><code>-o</code></td><td>Output directory</td><td>output</td></tr>
                        <tr><td><code>--dialect</code></td><td><code>-d</code></td><td>SQL dialect (mysql, postgres, sqlite)</td><td>auto</td></tr>
                        <tr><td><code>--tables</code></td><td><code>-t</code></td><td>Filter tables (comma-separated)</td><td>-</td></tr>
                        <tr><td><code>--progress</code></td><td><code>-p</code></td><td>Show progress</td><td>false</td></tr>
                        <tr><td><code>--dry-run</code></td><td>-</td><td>Preview without writing</td><td>false</td></tr>
                        <tr><td><code>--fail-fast</code></td><td>-</td><td>Stop on first error (glob)</td><td>false</td></tr>
                    </tbody>
                </table>
                <p class="note">Input accepts glob patterns: <code>*.sql</code>, <code>dumps/**/*.sql</code></p>
            </article>

            <!-- Validate Options -->
            <article class="guide-section">
                <h3>Validate Options</h3>
                <table class="options-table">
                    <thead>
                        <tr><th>Flag</th><th>Description</th><th>Default</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>--dialect</code></td><td>SQL dialect (mysql, postgres, sqlite)</td><td>auto</td></tr>
                        <tr><td><code>--strict</code></td><td>Treat warnings as errors</td><td>false</td></tr>
                        <tr><td><code>--json</code></td><td>JSON output for CI</td><td>false</td></tr>
                        <tr><td><code>--max-rows-per-table</code></td><td>Row limit for PK/FK checks (0 = unlimited)</td><td>1M</td></tr>
                        <tr><td><code>--no-limit</code></td><td>Disable row limit</td><td>false</td></tr>
                        <tr><td><code>--no-fk-checks</code></td><td>Skip PK/FK checks</td><td>false</td></tr>
                        <tr><td><code>--fail-fast</code></td><td>Stop on first error (glob)</td><td>false</td></tr>
                    </tbody>
                </table>
                <p class="note">Input accepts glob patterns: <code>*.sql</code>, <code>dumps/**/*.sql</code></p>
            </article>

            <!-- Supported Statements -->
            <article class="guide-section">
                <h3>Supported Statement Types</h3>
                <p>sql-splitter recognizes and routes these SQL statement types to their respective table files:</p>
                <div class="two-col">
                    <div>
                        <ul>
                            <li>CREATE TABLE</li>
                            <li>INSERT INTO</li>
                            <li>CREATE INDEX</li>
                        </ul>
                    </div>
                    <div>
                        <ul>
                            <li>ALTER TABLE</li>
                            <li>DROP TABLE</li>
                        </ul>
                    </div>
                </div>
                <p class="note">Other statements (SELECT, UPDATE, DELETE, etc.) are skipped.</p>
            </article>

            <!-- Examples -->
            <article class="guide-section">
                <h3>Examples</h3>

                <h4>Split a large production dump</h4>
                <div class="code-block">
                    <pre><code>sql-splitter split production-backup.sql -o tables -p</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter split production-backup.sql -o tables -p">Copy</button>
                </div>

                <h4>Extract only specific tables</h4>
                <div class="code-block">
                    <pre><code>sql-splitter split database.sql --tables=users,orders,products</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter split database.sql --tables=users,orders,products">Copy</button>
                </div>

                <h4>Preview before splitting</h4>
                <div class="code-block">
                    <pre><code>sql-splitter split database.sql --dry-run</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter split database.sql --dry-run">Copy</button>
                </div>

                <h4>Analyze tables before splitting</h4>
                <div class="code-block">
                    <pre><code>sql-splitter analyze database.sql</code></pre>
                    <button class="copy-btn" data-copy="sql-splitter analyze database.sql">Copy</button>
                </div>

                <h4>Import a single table</h4>
                <div class="code-block">
                    <pre><code>mysql -u root -p mydb < tables/users.sql</code></pre>
                    <button class="copy-btn" data-copy="mysql -u root -p mydb < tables/users.sql">Copy</button>
                </div>
            </article>

            <!-- Performance -->
            <article class="guide-section">
                <h3>Performance</h3>
                <p>Benchmarks on Apple M2 Max:</p>
                <table class="options-table">
                    <thead>
                        <tr><th>Metric</th><th>Value</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>Parser Throughput</td><td>400-500 MB/s</td></tr>
                        <tr><td>vs Go Version</td><td>1.25x faster on 10GB files</td></tr>
                        <tr><td>Memory Usage</td><td>~50 MB constant</td></tr>
                        <tr><td>Cold Start</td><td>~5ms</td></tr>
                    </tbody>
                </table>

                <p class="note">Actual performance depends on disk I/O speed and file complexity.</p>
            </article>

            <!-- FAQ -->
            <article class="guide-section">
                <h3>FAQ</h3>

                <details>
                    <summary>Does it modify my source file?</summary>
                    <div class="details-content">
                        <p>No. sql-splitter only reads from your source file. It never modifies the original.</p>
                    </div>
                </details>

                <details>
                    <summary>What about statements with semicolons in strings?</summary>
                    <div class="details-content">
                        <p>sql-splitter correctly handles semicolons inside quoted strings. It tracks quote boundaries and escape sequences.</p>
                    </div>
                </details>

                <details>
                    <summary>Can it handle multi-line statements?</summary>
                    <div class="details-content">
                        <p>Yes. The parser uses streaming and statement boundary detection, not line-based parsing.</p>
                    </div>
                </details>

                <details>
                    <summary>What about backtick-quoted table names?</summary>
                    <div class="details-content">
                        <p>Both backtick-quoted (<code>`table`</code>) and regular table names are supported.</p>
                    </div>
                </details>

                <details>
                    <summary>Why Rust instead of Go?</summary>
                    <div class="details-content">
                        <p>Rust's zero-cost abstractions and lack of garbage collection enable higher throughput. The Rust version achieves 1.25x faster performance than Go on large files, with lower memory usage and faster cold starts.</p>
                    </div>
                </details>

                <details>
                    <summary>Is it faster than other tools?</summary>
                    <div class="details-content">
                        <p>sql-splitter is among the fastest SQL splitters available, achieving 400+ MB/s throughput with minimal memory footprint thanks to Rust's ownership model and zero-copy parsing.</p>
                    </div>
                </details>
            </article>
        </section>
    </main>

    <footer>
        <p>
            <a href="https://github.com/helgesverre/sql-splitter">GitHub</a>
            <span class="sep">|</span>
            <a href="https://github.com/helgesverre/sql-splitter/releases">Releases</a>
            <span class="sep">|</span>
            <a href="https://github.com/helgesverre/sql-splitter/blob/main/LICENSE">MIT License</a>
            <span class="sep">|</span>
            <a href="llms.txt">llms.txt</a>
        </p>
        <p class="credit">Built by <a href="https://github.com/helgesverre">Helge Sverre</a></p>
    </footer>

    <script>
        // Copy button functionality
        document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const text = btn.dataset.copy;
                try {
                    await navigator.clipboard.writeText(text);
                    const original = btn.textContent;
                    btn.textContent = 'Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = original;
                        btn.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    btn.textContent = 'Failed';
                    setTimeout(() => btn.textContent = 'Copy', 2000);
                }
            });
        });
    </script>
</body>
</html>
